var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/#Pesistence-Diagrams-using-Sunny.jl-Datasets","page":"Tutorials","title":"Pesistence Diagrams using Sunny.jl Datasets","text":"","category":"section"},{"location":"#Phunny","page":"Home","title":"Phunny","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PHysicalTDA.","category":"page"},{"location":"#What's-PHysicalTDA?","page":"Home","title":"What's PHysicalTDA?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Topological data analysis for neutron scattering datasets.","category":"page"},{"location":"#Example-Usage","page":"Home","title":"Example Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using PHysicalTDA\n\n","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/alt-f4-dev/PHysicalTDA.jl\n","category":"page"},{"location":"Conventions/#Crystal-Lattices","page":"Crystal Lattices","title":"Crystal Lattices","text":"","category":"section"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"In general, a 3-dimensional crystal is defined using a Bravais lattice.  The Bravais lattice is defined by three primitive vectors veca_1, veca_2, and veca_3.  For the 3-dimensional Bravais lattice, these three primitive vectors are used to tesselate mathbbR^3:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"  vecr = n_1veca_1 + n_2veca_2 + n_3veca_3    n_1n_2n_3 in mathbbZ","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"In the simplest case, an atom may be placed directly on the Bravais points vecr.  In reality, it's extremely common for atoms to be at non-Bravais points, requiring basis positions vecdelta.  Then, the atomic position vector vecrprime = vecr + vecdelta. ","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"The Bravais lattice has a dual which is commonly referred to as the reciprocal-space or momentum-space lattice. The primitive vectors for the reciprocal-space lattice are defined:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"    beginsplit\n        vecb_1 = frac2piV(vecb_2 times vecb_1)\n        vecb_2 = frac2piV(b_3timesvecb_1)\n        vecb_3 = frac2piV(vecb_1timesvecb_2)\n    endsplit","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"where V = vecb_1cdot(vecb_2timesvecb_3) is the volume of the unit cell. The reciprocal-space lattice is tesselated:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"vecq = hvecb_1 + kvecb_2 + ellvecb_3","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"where hkell define the \\text{Miller indices} of the wave-vector vecq.  The Miller indices define the spacing between planes in the reciprocal lattice:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"d = frac2pivecq_hkell","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"The reciprocal-space vectors are translationally symmetric such that vecq = vecq + veck  for veck in vecq_m belonging to the set of reciprocal lattice points.","category":"page"},{"location":"Conventions/#Scattering-Theory","page":"Crystal Lattices","title":"Scattering Theory","text":"","category":"section"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"The one-phonon dynamic structure factor is the spectral function corresponding to inelastic scattering  events where the energy transfer Delta E neq 0. During the inelastic scattering, the neutron either  loses energy (creates a phonon) or gains energy (destroys a phonon). The one-phonon contribution to the  structure factor is defined:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"S_textph^pm(vecqomega beta) = sum_nusum_veckA_nu(vecq)Delta_nu^pm(vecqveck)left(n_nu(beta) + frac1 pm 12right)","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"where A_nu(vecq) is the scattering amplitude of the nu^th phonon mode induced by the momentum transfer mathbfq. The scattering amplitude is related to the nu^th phonon mode polarization vector vecxi_nu such that A_nu(mathbfq) = (vecqcdotvecxi_nu)^2omega_nu  for single-phonon scattering events.The Bose-Einstein distribution includes the thermal dependence such that n_nu(beta) = e^-betahbaromega_nu - 1^-1 with beta = (k_bT)^-1. The selection rules for scattering are enforced by,Delta_nu^pm(vecqveck) = delta(omega pm omega_nu)delta(mathbfq -mathbfk) where delta() denotes a Dirac delta. ","category":"page"},{"location":"refs/#Reference","page":"References","title":"Reference","text":"","category":"section"},{"location":"refs/#Contents","page":"References","title":"Contents","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"Pages = [\"refs.md\"]","category":"page"},{"location":"refs/#Index","page":"References","title":"Index","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"Pages = [\"refs.md\"]","category":"page"},{"location":"refs/#PHysicalTDA.AX","page":"References","title":"PHysicalTDA.AX","text":"Collapse (reduce) a 4D array over one or more axes with specified operation (default operation is :sum). Axes may be symbols (:h,:k,:ℓ,:ω) [Julia Syntax] or integer indices [Python Syntax]. Reduces highest axes first to keep indices stable. Returns collapsed (reduced) array.\n\nNote, the indexing convention in Julia is such that (JuliaArr[1] ~ PythonArr[0]).\n\n\n\n\n\n","category":"constant"},{"location":"refs/#PHysicalTDA.LSWT-Tuple{Any, Any}","page":"References","title":"PHysicalTDA.LSWT","text":"Computes LSWT S(q,ω) on a coarse 3D Q-grid and along several q-space paths. Build Gaussian-broadened 2D intensity and multiple 1D path scans in parallel. Returns ([results2D, Qs], [resultalongpaths, paths], energies)\n\nAssumes input is a Sunny.System corresponding to the provided Sunny.Crystal type.\n\n\n\n\n\n","category":"method"},{"location":"refs/#PHysicalTDA.La2CuO4-Tuple{}","page":"References","title":"PHysicalTDA.La2CuO4","text":"Constructs a tetragonal La₂CuO₄-like crystal and Sunny spin system. Applies J, J′, J″, Jc exchanges, randomizes spins, and minimizes energy. Returns (crystal, system)\n\nSpace Group: 139 ~ Single Cu Ion @ [0,0,0] | (s=1/2, g=2) Supercell: (6x6x3) \n\nReturns (cryst::Sunny.Crystal, sys::Sunny.System).\n\n\n\n\n\n","category":"method"},{"location":"refs/#PHysicalTDA.MAD-Tuple{Any}","page":"References","title":"PHysicalTDA.MAD","text":"Median Absolute Deviation (MAD) Applies elementwise relative to the median of t.  Suitable for thresholding outliers in intensity arrays. Returns an array of MAD values with the same shape as t.\n\n\n\n\n\n","category":"method"},{"location":"refs/#PHysicalTDA.betti_curvature-Tuple{Any, AbstractVector{<:Real}}","page":"References","title":"PHysicalTDA.betti_curvature","text":"betti_curvature(pd, τ; dims = 0:1, scheme = :forward)\n\nCompute βp(τ) and κp(τ) = dβ_p/dτ on a grid τ.\n\nscheme = :forward (default) uses forward differences and sets κ[end]=κ[end-1]. Use :central for central differences on interior points.\n\nReturns (β::Dict{Int,Vector{Int}}, κ::Dict{Int,Vector{Float64}}).\n\n\n\n\n\n","category":"method"},{"location":"refs/#PHysicalTDA.betti_curve-Tuple{Any, AbstractVector{<:Real}}","page":"References","title":"PHysicalTDA.betti_curve","text":"betti_curve(pd, τ; dims = 0:1)\n\nCompute per-dimension Betti curves βp(τj) on a user-provided grid τ.\n\npd is a Ripserer PD (grouped by degree).\nτ is a sorted vector of thresholds (monotone increasing).\n\nReturns Dict{Int,Vector{Int}} mapping p ↦ β_p(τ).\n\n\n\n\n\n","category":"method"},{"location":"refs/#PHysicalTDA.convert4D-Tuple{Any, Any, Any}","page":"References","title":"PHysicalTDA.convert4D","text":"Reshape Sunny intensities from (ω, q) or (q, ω) into a 4D cube (h,k,ℓ,ω). Validates sizes given Q-grid shape, then reshapes/permutedims accordingly. Error thrown if flattened data size does not match nω × nQ. Returns a 4D Array with axis order (h,k,ℓ,ω).\n\n\n\n\n\n","category":"method"},{"location":"refs/#PHysicalTDA.pd_array_intensity-Union{Tuple{AbstractArray{<:Real, N}}, Tuple{N}} where N","page":"References","title":"PHysicalTDA.pd_array_intensity","text":"Computes persistance diagrams of an intensity array via cubical complexes. Returns (PD, Figure) with birth–death scatter per dimension up to maxdim.\n\nOptional superlevel filtration (invert intensities) and normalization to [0,1]. Used to analyze the topology of S(Q,ω) slices or projections.\n\nNote, superlevel and normalization need validation tests!\n\n\n\n\n\n","category":"method"},{"location":"refs/#PHysicalTDA.pd_sunny_intensities-Union{Tuple{Sunny.Intensities{T, G, N}}, Tuple{N}, Tuple{G}, Tuple{T}} where {T<:Real, G, N}","page":"References","title":"PHysicalTDA.pd_sunny_intensities","text":"Wrapper: Sunny.Intensities -> dense Array -> pdarrayintensity\n\nConverts I.data to a dense array and calls pd_array_intensity. Respects maxdim and superlevel. Returns (PD, Figures).\n\nConvenient for topology on LSWT or phonon intensity objects.\n\n\n\n\n\n","category":"method"},{"location":"refs/#PHysicalTDA.persistence_entropy-Tuple{Any}","page":"References","title":"PHysicalTDA.persistence_entropy","text":"persistence_entropy(pd; dims = 0:1, tol = 0.0)\n\nCompute per-dimension persistence entropy Sp and total persistence Ep.\n\npd is a Ripserer persistence diagram, grouped by homology degree as returned by ripserer(...).\ndims selects homology degrees (default 0:1).\ntol discards lifetimes ≤ tol (guards numerical noise).\n\nReturns (S::Dict{Int,Float64}, E::Dict{Int,Float64}) keyed by p.\n\n\n\n\n\n","category":"method"}]
}
